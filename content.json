{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"安装Gitalk评论插件报403错误的解决办法","text":"1、设置前提首先在Github中Authorized OAuth Apps中的Homepage URL和Authorization callback URL要设置正确，本文是这2个值都一样，都是博客地址的首页地址，即：https://lzj09.github.io，注意协议http和https是严格区别的。 2、问题呈现当配置好Gitallk后，首次访问时，会有如下页面： 如果配置没错的话，首次出现这个页面是正确的，然后点击“使用 GitHub 登录”，登录授权后，如果出现403错误，即： 通过查看浏览器F12中的网络，可以发现，其实是获取access token时，报了403错误，即： Gitalk是通过代理的方式获取token，现在说明这个https://cors-anywhere.herokuapp.com代理不行，所以得换一个代理。 3、解决办法在网上找到代理https://cors.bridged.cc,是可以用的，所以更换一下配置，配置proxy，即： 1proxy: 'https://cors.bridged.cc/https://github.com/login/oauth/access_token' 重新部署一下即可。","link":"/2021/04/12/gitalk-error-code-403/"},{"title":"Go类型转换错误Cannot convert an expression of the type &#39;interface{}&#39; to the type &#39;XXX&#39;","text":"1、问题引出在编码中经常会涉及到类型转换的问题，在Go语言中也是一样的，一次在开发中将interface{}类型强制转换成具体类型时，出现了如下错误： 1Cannot convert an expression of the type 'interface{}' to the type 'Person' 为了引出该问题，在此先引入3个结构体，即： 1234567891011121314151617// Person结构体type Person struct { Name string Age int}// Student结构体type Student struct { Name string Age int}// Obj结构体type Obj struct { ID int Type interface{}} 创建一个person对象和obj对象： 123456789person := Person{ Name: &quot;lzj&quot;, Age: 20,}obj := Obj{ ID: 1, Type: person,} 由于Student结构体与Person结构体中的字段和类型都是一样的，其实是可以将person对象强制转换成student对象的，即： 12student := Student(person)fmt.Printf(&quot;Student: Name: %v, Age: %v\\n&quot;, student.Name, student.Age) 这里是可以成功的，而且输出结果为： 1Student: Name: lzj, Age: 20 如果将obj对象中的Type属性值转换Person结构体对象，也是按照以上的这种强制转换的话，就会有问题，即： 12p := Person(obj.Type)// 该代码会报错：Cannot convert an expression of the type 'interface{}' to the type 'Person' 2、解决办法interface{}转换成其它类型，所用的方式为： 1结果 := interface类型.(转换的类型) 所以上述的转换需要改成： 12p := obj.Type.(Person)fmt.Printf(&quot;Person: Name: %v, Age: %v\\n&quot;, p.Name, p.Age) 这样就可以转换成功，并输入结果为： 1Person: Name: lzj, Age: 20","link":"/2021/04/17/go-convert-type-error/"},{"title":"Go语言中图片与Base64互相转换","text":"1、图片转成Base6412345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;encoding/base64&quot; &quot;fmt&quot; &quot;os&quot;)func main() { file, err := os.Open(&quot;jw.png&quot;) if err != nil { fmt.Printf(&quot;os open file error %v\\n&quot;, err) return } defer file.Close() // 获取文件的统计相关信息 info, err := file.Stat() if err != nil { fmt.Printf(&quot;file stat error %v\\n&quot;, err) return } srcBuffer := make([]byte, info.Size()) n, err := file.Read(srcBuffer) if err != nil { fmt.Printf(&quot;file read error %v\\n&quot;, err) return } // 转base64 base64Str := base64.StdEncoding.EncodeToString(srcBuffer[:n]) fmt.Printf(&quot;Base64: %v\\n&quot;, base64Str)} 2、Base64转成图片1234567891011121314151617181920212223242526package mainimport ( &quot;encoding/base64&quot; &quot;fmt&quot; &quot;os&quot;)func main() { base64Str := &quot;xxxxx&quot; base64Bytes, err := base64.StdEncoding.DecodeString(base64Str) if err != nil { fmt.Printf(&quot;base64 decode string error %v\\n&quot;, err) return } // 创建图片 newFile, err := os.OpenFile(&quot;demo004/new.png&quot;, os.O_RDWR|os.O_CREATE, os.ModePerm) if err != nil { fmt.Printf(&quot;os open new file error %v\\n&quot;, err) return } defer newFile.Close() newFile.Write(base64Bytes)}","link":"/2021/04/20/go-img-base64/"},{"title":"Flex布局中文字被挤压的问题解决办法","text":"1、问题重现在Flex布局内有2个元素，其中一个为标题，另一个为内容，如果内容比较多时，则会出现标题被挤压换行的现象，即： 1234&lt;div class=&quot;test&quot;&gt; &lt;p&gt;测试项：&lt;/p&gt; &lt;p&gt;测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容&lt;/p&gt;&lt;/div&gt; 其中test的样式为： 123.test { display: flex;} 结果为： 2、解决办法为Flex布局内的第一个元素加上flex-shrink样式，并且设置为0，即： 123.test &gt; p:first-child { flex-shrink: 0;} 效果为：","link":"/2021/05/12/flex-word-shrink-error/"},{"title":"2021年个人目标","text":"2021年都快过一半了，但是为了能够提醒自己，还是将2021年的个人目标罗列出来，作个记录。年终时可以看看完成度。 2021年主要有3个个人目标：考系统架构师证；精读5本书；利用所学知识在互联网中赚100元。 1、考系统架构师证今年11月份考系统架构师，如果从现在开始计算的话，最多只有5个月的准备时间。但一般也只能用周未的时间准备。虽然时间有点紧，但值得冲刺一下！ 2、精读5本书利用半年的时间，精读5本书应该问题不大。但是每读完1本书，需要感悟，而且要用文字的形式记录下来！ 3、利用所学知识在互联网中赚100元目前打算利用自己的编程方面的知识或计算机相关的知识，在互联网平台上赚100元，对我来说，在这方面以前没有真正尝试过，但值得搏一下！","link":"/2021/05/15/goal-for-2021/"},{"title":"Lambda表达式与匿名内部类的内部实现区别","text":"在Java8提供Lambda表达式后，有些地方可以用比较简洁的Lambda表达式来代替原来相对冗余的匿名内部类了。那么Java在低层实现时，这2种方式有什么区别呢，下面通过例子来分析一下。 1、简单实例下面列出一个简单的类，类中提供了2 个方式，一个方式用匿名内部类的方式实现；另一个用Lambda表达式的方式实现，即： 1234567891011121314151617181920212223242526package io.github.lzj09.java8.lambda;public class LambdaDemo1 { public static void main(String[] args) { LambdaDemo1 demo = new LambdaDemo1(); demo.anonymousClassMethod(); demo.lambdaFunctionMethod(); } public void anonymousClassMethod() { new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;匿名内部类方式执行...&quot;); } }).start(); } public void lambdaFunctionMethod() { new Thread(() -&gt; System.out.println(&quot;lambda函数方式执行...&quot;)).start(); }} 程序很简单，输出的结果为： 12匿名内部类方式执行...lambda函数方式执行... 2、分析生成的对应的class字节码文件查看classes文件夹中的字节码文件中，会发现有2个class文件，即LambdaDemo1.class和LambdaDemo1$1.class，如图： 利用javap命令查看这2个class文件对应的汇编指令，首先看看LambdaDemo1$1.class文件，即输入如下命令： 1javap -c -p LambdaDemo1$1.class 结果如下： 1234567891011121314151617181920Compiled from &quot;LambdaDemo1.java&quot;class io.github.lzj09.java8.lambda.LambdaDemo1$1 implements java.lang.Runnable { final io.github.lzj09.java8.lambda.LambdaDemo1 this$0; io.github.lzj09.java8.lambda.LambdaDemo1$1(io.github.lzj09.java8.lambda.LambdaDemo1); Code: 0: aload_0 1: aload_1 2: putfield #12 // Field this$0:Lio/github/lzj09/java8/lambda/LambdaDemo1; 5: aload_0 6: invokespecial #14 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return public void run(); Code: 0: getstatic #22 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #28 // String 匿名内部类方式执行... 5: invokevirtual #30 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return} 从上面的汇编指令大致可以看到LambdaDemo1$1类实现了Runnable接口，并实现run()方法，同时该方法输入一个字符串，即“匿名内部类方式执行…”。 从上可以看出匿名内部类在编译时，会生成一个类并实现Runnable接口同时实现run()方法。 再利用javap命令查看LambdaDemo1.class文件，即： 1javap -c -p LambdaDemo1.class 结果为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Compiled from &quot;LambdaDemo1.java&quot;public class io.github.lzj09.java8.lambda.LambdaDemo1 { public io.github.lzj09.java8.lambda.LambdaDemo1(); Code: 0: aload_0 1: invokespecial #8 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #1 // class io/github/lzj09/java8/lambda/LambdaDemo1 3: dup 4: invokespecial #16 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #17 // Method anonymousClassMethod:()V 12: aload_1 13: invokevirtual #20 // Method lambdaFunctionMethod:()V 16: return public void anonymousClassMethod(); Code: 0: new #26 // class java/lang/Thread 3: dup 4: new #28 // class io/github/lzj09/java8/lambda/LambdaDemo1$1 7: dup 8: aload_0 9: invokespecial #30 // Method io/github/lzj09/java8/lambda/LambdaDemo1$1.&quot;&lt;init&gt;&quot;:(Lio/github/lzj09/java8/lambda/LambdaDemo1;)V 12: invokespecial #33 // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V 15: invokevirtual #36 // Method java/lang/Thread.start:()V 18: return public void lambdaFunctionMethod(); Code: 0: new #26 // class java/lang/Thread 3: dup 4: invokedynamic #42, 0 // InvokeDynamic #0:run:()Ljava/lang/Runnable; 9: invokespecial #33 // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V 12: invokevirtual #36 // Method java/lang/Thread.start:()V 15: return private static void lambda$0(); Code: 0: getstatic #44 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #50 // String lambda函数方式执行... 5: invokevirtual #52 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return} 从上可以发现，多了一个方法lambda$0()，而该方法内容刚好是Lambda表达式中的内容，即输出“lambda函数方式执行…”。到这其实会有一个疑问，这个lambda$0()方法，在哪里被调用呢？这时需要利用java命令执行时，加入-Djdk.internal.lambda.dumpProxyClasses参数，这样才能真正看到lambda$0()方法调用过程，即： 1java -Djdk.internal.lambda.dumpProxyClasses io.github.lzj09.java8.lambda.LambdaDemo1 执行该命令后，同样是会输出结果，即： 12匿名内部类方式执行...lambda函数方式执行... 但是查看classes文件，会发现多了一个class文件LambdaDemo1$$Lambda$1.class，如图： 同样用javap命令查看LambdaDemo1$$Lambda$1.class的汇编指令，即： 1javap -c -p LambdaDemo1$$Lambda$1.class 得到如下结果： 123456789101112final class io.github.lzj09.java8.lambda.LambdaDemo1$$Lambda$1 implements java.lang.Runnable { private io.github.lzj09.java8.lambda.LambdaDemo1$$Lambda$1(); Code: 0: aload_0 1: invokespecial #10 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public void run(); Code: 0: invokestatic #17 // Method io/github/lzj09/java8/lambda/LambdaDemo1.lambda$0:()V 3: return} 可以发现类LambdaDemo1$$Lambda$1实现了Runnable接口，并实现run()方法，同时该方法中就是调用LambdaDemo1类中编译时生成的lambda$0()方法的。 3、总结Lambda表达式与匿名内部类的低层实现过程还是有些区别的： 匿名内部类 是在编译时，新增一个class，同时该class中实现相应的接口和方法。 Lambda表达式 编译时会先新增一个方法，该方法内容即为Lambda表达式中的内容. 运行时会新增一个class，同时该class中实现相应的接口和方法，但方法中是调用第1步中生成的方法。","link":"/2021/05/15/java8-lambda-vs-anonymous/"},{"title":"TypeScript整合Webpack开发工程","text":"1、初始化项目首先在合适的目录下创建ts-webpack文件夹，然后在该文件夹所在的目录下执行npm的初始化命令，即： 1npm init 然后根据提示的输入相应的信息即可，如果图简单，一直按回车键即可。 2、新增基本依赖包初始化好项目后，紧接着添加TypeScript与Webpack整合的基本依赖包ts-loader, typescript, webpack, webpack-cli，即输入命令： 1npm install ts-loader, typescript, webpack, webpack-cli 3、新增tsconfig.json配置文件tsconfig.json配置，可以通过tsc命令生成，即在工程目录下输入如下命令： 1tsc --init 则在工程目录下会有tsconfig.json文件，文件内容为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071{ &quot;compilerOptions&quot;: { /* Visit https://aka.ms/tsconfig.json to read more about this file */ /* Basic Options */ // &quot;incremental&quot;: true, /* Enable incremental compilation */ &quot;target&quot;: &quot;es5&quot;, /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */ &quot;module&quot;: &quot;commonjs&quot;, /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */ // &quot;lib&quot;: [], /* Specify library files to be included in the compilation. */ // &quot;allowJs&quot;: true, /* Allow javascript files to be compiled. */ // &quot;checkJs&quot;: true, /* Report errors in .js files. */ // &quot;jsx&quot;: &quot;preserve&quot;, /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */ // &quot;declaration&quot;: true, /* Generates corresponding '.d.ts' file. */ // &quot;declarationMap&quot;: true, /* Generates a sourcemap for each corresponding '.d.ts' file. */ // &quot;sourceMap&quot;: true, /* Generates corresponding '.map' file. */ // &quot;outFile&quot;: &quot;./&quot;, /* Concatenate and emit output to single file. */ // &quot;outDir&quot;: &quot;./&quot;, /* Redirect output structure to the directory. */ // &quot;rootDir&quot;: &quot;./&quot;, /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ // &quot;composite&quot;: true, /* Enable project compilation */ // &quot;tsBuildInfoFile&quot;: &quot;./&quot;, /* Specify file to store incremental compilation information */ // &quot;removeComments&quot;: true, /* Do not emit comments to output. */ // &quot;noEmit&quot;: true, /* Do not emit outputs. */ // &quot;importHelpers&quot;: true, /* Import emit helpers from 'tslib'. */ // &quot;downlevelIteration&quot;: true, /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */ // &quot;isolatedModules&quot;: true, /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */ /* Strict Type-Checking Options */ &quot;strict&quot;: true, /* Enable all strict type-checking options. */ // &quot;noImplicitAny&quot;: true, /* Raise error on expressions and declarations with an implied 'any' type. */ // &quot;strictNullChecks&quot;: true, /* Enable strict null checks. */ // &quot;strictFunctionTypes&quot;: true, /* Enable strict checking of function types. */ // &quot;strictBindCallApply&quot;: true, /* Enable strict 'bind', 'call', and 'apply' methods on functions. */ // &quot;strictPropertyInitialization&quot;: true, /* Enable strict checking of property initialization in classes. */ // &quot;noImplicitThis&quot;: true, /* Raise error on 'this' expressions with an implied 'any' type. */ // &quot;alwaysStrict&quot;: true, /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */ /* Additional Checks */ // &quot;noUnusedLocals&quot;: true, /* Report errors on unused locals. */ // &quot;noUnusedParameters&quot;: true, /* Report errors on unused parameters. */ // &quot;noImplicitReturns&quot;: true, /* Report error when not all code paths in function return a value. */ // &quot;noFallthroughCasesInSwitch&quot;: true, /* Report errors for fallthrough cases in switch statement. */ // &quot;noUncheckedIndexedAccess&quot;: true, /* Include 'undefined' in index signature results */ // &quot;noPropertyAccessFromIndexSignature&quot;: true, /* Require undeclared properties from index signatures to use element accesses. */ /* Module Resolution Options */ // &quot;moduleResolution&quot;: &quot;node&quot;, /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */ // &quot;baseUrl&quot;: &quot;./&quot;, /* Base directory to resolve non-absolute module names. */ // &quot;paths&quot;: {}, /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */ // &quot;rootDirs&quot;: [], /* List of root folders whose combined content represents the structure of the project at runtime. */ // &quot;typeRoots&quot;: [], /* List of folders to include type definitions from. */ // &quot;types&quot;: [], /* Type declaration files to be included in compilation. */ // &quot;allowSyntheticDefaultImports&quot;: true, /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ &quot;esModuleInterop&quot;: true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */ // &quot;preserveSymlinks&quot;: true, /* Do not resolve the real path of symlinks. */ // &quot;allowUmdGlobalAccess&quot;: true, /* Allow accessing UMD globals from modules. */ /* Source Map Options */ // &quot;sourceRoot&quot;: &quot;&quot;, /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // &quot;mapRoot&quot;: &quot;&quot;, /* Specify the location where debugger should locate map files instead of generated locations. */ // &quot;inlineSourceMap&quot;: true, /* Emit a single file with source maps instead of having a separate file. */ // &quot;inlineSources&quot;: true, /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */ /* Experimental Options */ // &quot;experimentalDecorators&quot;: true, /* Enables experimental support for ES7 decorators. */ // &quot;emitDecoratorMetadata&quot;: true, /* Enables experimental support for emitting type metadata for decorators. */ /* Advanced Options */ &quot;skipLibCheck&quot;: true, /* Skip type checking of declaration files. */ &quot;forceConsistentCasingInFileNames&quot;: true /* Disallow inconsistently-cased references to the same file. */ }} 可以根据具体情况调整相应的参数，在这就保持默认配置。 4、新增webpack.config.js配置文件首先在工程目录下新建一个src文件夹，用于存放TypeScript相关源代码的，先在src文件夹中新建index.ts文件，用于工程的入口文件。 在工程目录下新建webpack.config.js配置文件，并加入基本配置，即： 12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = { // 入口文件 entry: &quot;./src/index.ts&quot;, // 指定打包文件所在目录 output: { // 打包文件目录 path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件名 filename: &quot;bundle.js&quot;, }, // 设置mode模式， development：开发环境，production：生产环境 mode: &quot;production&quot;, // 指定打包的模块 module: { // 指定加载规则 rules: [ { // 指定规则生效的文件 test: /\\.ts$/, use: &quot;ts-loader&quot;, // 要排除的文件 exclude: /node_modules/ } ] }} 在package.json文件中的scripts中加入打包命令，即： 1234&quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack&quot;,} 到目前为止，本工程已经将TypeScript和Webpack做了基本整合了，可以测试一下，首先在入口文件index.ts中加入一个ts测试代码，即： 12345function sum(num1:number, num2:number):number { return num1 + num2;}console.log(sum(10, 20)); 然后输入打包命令，即： 1npm run build 可以发现在工程目录下多了一个dist文件夹，里面有bundle.js文件。 5、引入html-webpack-plugin、clean-webpack-plugin和webpack-dev-server目前工程虽然可以正常打包将ts转换成js，但是要验证js的效果却比较麻烦，还需要手动创建html文件，然后将打包生成的js文件引入测试。 可以通过html-webpack-plugin插件，可以自动的将html模板文件中引入打包后js文件，即首先添加依赖： 1npm install html-webpack-plugin 然后在webpack.config.js配置文件中首先引入这个插件，即： 12// 引入html插件const HTMLWebpackPlugin = require('html-webpack-plugin'); 然后新增plugins配置，即： 123456// 配置插件plugins: [ new HTMLWebpackPlugin({ template: &quot;./src/index.html&quot; }),] 其中index.html就是模板文件，打包后会自动将js文件引入到该文件中。 同时为了能够自动运行工程，可以通过webpack-dev-server实现，首先添加依赖： 1npm install webpack-dev-server 然后在package.json文件中加入启动命令，即在scripts配置中加入： 1&quot;start&quot;: &quot;webpack serve --open chrome.exe&quot; 即运行命令： 1npm run start 时，会自动打开chrome浏览器，然后加载index.html与js整合后的文件，这样就可以看到开发的效果了，同时还是支持执行部署的，即修改了ts文件后，会自动在浏览器中有效果。 为了防止打包过程中出现缓存导致的问题，可以通过clean-webpack-plugin插件解决，先添加依赖后，然后在webpack.config.js配置文件中引入该插件，即： 12// 引入clean插件const { CleanWebpackPlugin } = require('clean-webpack-plugin'); 然后在plugins配置加入，即： 123456789// 配置插件plugins: [ // 清除缓存 new CleanWebpackPlugin(), new HTMLWebpackPlugin({ template: &quot;./src/index.html&quot; }),], 6、整合babel为了ts转换的js兼容各种浏览器，则整合babel，首先添加相应的依赖，即： 1npm install @babel/core, @babel/preset-env, babel-loader, core-js 然后修改webpack.config.js配置文件，即修改use配置项，即改成： 123456789101112131415161718192021222324252627282930use: [ // 配置babel { // 指定加载器 loader: &quot;babel-loader&quot;, // 设置babel options: { // 设置预定义环境 presets: [ [ // 指定环境的插件 &quot;@babel/preset-env&quot;, // 配置信息 { // 需要兼容的目标浏览器 targets: { &quot;chrome&quot;: &quot;88&quot;, &quot;ie&quot;: &quot;11&quot; }, &quot;corejs&quot;: &quot;3&quot;, // 使用corejs的方式，按需加载 &quot;useBuiltIns&quot;: &quot;usage&quot; } ] ] } }, &quot;ts-loader&quot;] 其中各个配置项上方都有相应的说明。 至此TypeScript与Webpack就整合完成了，完整项目在Github中，即：https://github.com/lzj09/ts-webpack","link":"/2021/05/30/typescript-integrate-webpack/"},{"title":"Zookeeper3.8.0集群部署","text":"1、环境准备集群部署zookeeper的节点数只能是奇数，在此部署3节点zookeeper集群，节点环境如下： 主机名 IP 架构 操作系统 hadoop01 192.168.194.133 x86_64 CentOS Linux 7 (Core) hadoop02 192.168.194.134 x86_64 CentOS Linux 7 (Core) hadoop03 192.168.194.135 x86_64 CentOS Linux 7 (Core) zookeeper是基于java开发的，所以部署zookeeper前要有Java的环境，在些部署OpenJDK8，下载地址为： 1234https://www.openlogic.com/openjdk-downloads# 为了加速下载，也可以下从国内镜像源下载，如：https://mirrors.tuna.tsinghua.edu.cn/Adoptium OpenJDK下载后，解压到相应的目录，并配置环境变量即可（3个节点都得配置），如： 12345678# 在/etc/profile中加入如下内容export JAVA_HOME=/opt/openjdk-8u332-b09export PATH=$PATH:$JAVA_HOME/bin# 保存好/etc/profile文件后，执行source /etc/profile# 检验环境变量，是否起效，可以用java或者javac命令测试 2、部署Zookeeper首先到官网下载zookeeper，选择相应的版本，在此选用的3.8.0版本，下载地址为： 1234567# 官网地址https://zookeeper.apache.org/releases.html#download# 如果下载速度慢，也可以用国内镜像源下载，如：https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper# 注意：要选择下载带-bin的压缩包，不带-bin的压缩包是源码包！！！ 下载好后，先将压缩包解压到1台服务器，如hadoop01（192.168.194.133）上，在此解压到目录为/opt/bigdata中，即： 1/opt/bigdata/zookeeper-3.8.0 2.1、修改配置在zookeeper-3.8.0目录下新增data和logs文件夹，分别为数据目录、日志目录。 将conf文件夹中的zoo_sample.cfg复制为zoo.cfg，即： 1cp zoo_sample.cfg zoo.cfg 并修改zoo.cfg中内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/opt/bigdata/zookeeper-3.8.0/datadataLogDir=/opt/bigdata/zookeeper-3.8.0/logs# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1## Metrics Providers## https://prometheus.io Metrics Exporter#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider#metricsProvider.httpHost=0.0.0.0#metricsProvider.httpPort=7000#metricsProvider.exportJvmInfo=true# 在此配置是主机名，所以每个节点的/etc/hosts中要配置域名映射server.1=hadoop01:2888:3888server.2=hadoop02:2888:3888server.3=hadoop03:2888:3888 并在数据目录data中创建myid文件，并将1写入。 将zookeeper-3.8.0目录复制到hadoop02和hadoop03服务器上，即： 12scp -r zookeeper-3.8.0 root@hadoop02:/opt/bigdata/scp -r zookeeper-3.8.0 root@hadoop03:/opt/bigdata/ 注意：此时修改将hadoop02中data下的myid文件中内容改成2，将hadoop03中data下的myid文件中的内容改成3。 2.2、配置环境变量3个节点都得配置zookeeper的环境变量，即在/etc/profile中加入如下内容： 1234567export ZK_HOME=/opt/bigdata/zookeeper-3.8.0# PATH得修改为export PATH=$PATH:$JAVA_HOME/bin:$ZK_HOME/bin# 使环境变量生效source /etc/profile 2.3、启动由于3个zookeeper之间有通信，为此最将3个节点的防火墙关闭，即： 12systemctl stop firewalldsystemctl disable firewalld 然后3个节点依次启动zookeeper服务，即： 1zkServer.sh start 都启动后，可以查看每个节点的状态，即： 1234567zkServer.sh status# 如果返回结果中的Mode为follower则是从节点，为leader则为主节点，例如：ZooKeeper JMX enabled by defaultUsing config: /opt/bigdata/zookeeper-3.8.0/bin/../conf/zoo.cfgClient port found: 2181. Client address: localhost. Client SSL: false.Mode: leader","link":"/2022/07/13/zookeeper-cluster-deployment/"}],"tags":[{"name":"Gitalk","slug":"Gitalk","link":"/tags/Gitalk/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Base64","slug":"Base64","link":"/tags/Base64/"},{"name":"Flex","slug":"Flex","link":"/tags/Flex/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"个人目标","slug":"个人目标","link":"/tags/%E4%B8%AA%E4%BA%BA%E7%9B%AE%E6%A0%87/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"Zookeeper","slug":"Zookeeper","link":"/tags/Zookeeper/"},{"name":"Hadooop","slug":"Hadooop","link":"/tags/Hadooop/"}],"categories":[{"name":"问题解答库","slug":"问题解答库","link":"/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94%E5%BA%93/"},{"name":"Go基础库","slug":"Go基础库","link":"/categories/Go%E5%9F%BA%E7%A1%80%E5%BA%93/"},{"name":"我","slug":"我","link":"/categories/%E6%88%91/"},{"name":"Java8","slug":"Java8","link":"/categories/Java8/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}